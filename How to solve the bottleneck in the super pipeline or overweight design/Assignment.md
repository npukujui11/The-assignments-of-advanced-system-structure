#### 选题

* CPU既传统又现代。从传统的结构而言，CPU实现冯氏结构，从功能上一般可以分为取指、译码、执行、访存和回写5 个步骤来实现通用型的计算。但经过几十年的快速发展，现代CPU 普遍采用超级流水线和超标量来提升算力。请调研当前超级流水线或者超标量设计中的瓶颈，并从体系结构的角度分析可行的解决方案。

#### 内容

##### 愿得一人心，白首不相离：单指令周期处理器

* 一条 CPU 指令的执行，是由“取得指令（Fetch）- 指令译码（Decode）- 执行指令（Execute） ”这样三个步骤组成的。这个执行过程，至少需要花费一个时钟周期。因为在取指令的时候，我们需要通过时钟周期的信号，来决定计数器的自增。

* 那么，很自然地，我们希望能确保让这样一整条指令的执行，在一个时钟周期内完成。这样，我们一个时钟周期可以执行一条指令，CPI 也就是 1，看起来就比执行一条指令需要多个时钟周期性能要好。采用这种设计思路的处理器，就叫作单指令周期处理器（Single Cycle Processor），也就是在一个时钟周期内，处理器正好能处理一条指令。

* 不过，我们的时钟周期是固定的，但是指令的电路复杂程度是不同的，所以实际一条指令执行的时间是不同的。

* 不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好把时钟周期和执行时间最长的那个指令设成一样。这就好比学校体育课 1000 米考试，我们要给这场考试预留的时间，肯定得和跑得最慢的那个同学一样。因为就算其他同学先跑完，也要等最慢的同学跑完，我们才能进行下一项活动。

*  <div align=center><img src="picture/单指令周期处理器时钟周期.jpg"
        alt="No Picture"
        style="zoom:50%"/>
        <center><p>单指令处理器的时钟周期</p></center>
    </div>
    快速执行完成的指令，需要等待满一个时钟周期，才能执行下一条指令

* 所以，在单指令周期处理器里面，无论是执行一条用不到 ALU 的无条件跳转指令，还是一条计算起来电路特别复杂的浮点数乘法运算，我们都等要等满一个时钟周期。在这个情况下，虽然 CPI 能够保持在 1，但是我们的时钟频率却没法太高。因为太高的话，有些复杂指令没有办法在一个时钟周期内运行完成。那么在下一个时钟周期到来，开始执行下一条指令的时候，前一条指令的执行结果可能还没有写入到寄存器里面。那下一条指令读取的数据就是不准确的，就会出现错误。

* <div align=center><img src="picture/指令的写入和读取.jpg"
        alt="No Picture"
        style="zoom:50%"/>
        <center><p>最复杂指令问题</p></center>
    </div>
    一条指令的写入，在后一条指令的读取之前。因此单指令周期处理器，可以认为其时钟周期是执行最复杂的指令的时间。

##### 无可奈何花落去，似曾相识燕归来：现代处理器的流水线设计

* 目前应用在各个领域的CPU都不是单指令周期处理器，其采用了一种叫做指令流水线（Instruction Pipeline）的技术。

* CPU执行一条指令的过程被拆分成“取指令、译码、执行”三大步骤。更细分一些，执行的过程，还包含从寄存器或者内存中读取数据，通过 ALU 进行运算，把结果写回到寄存器或者内存中。

* CPU的执行执行过程：在取指令的时候，通过一个译码器把数据从内存里面取出来，写入到寄存器中；在指令译码的时候，通过另外一个译码器，把指令解析成对应的控制信号、内存地址和数据；到了指令执行的时候，通过一个完成计算工作的 ALU。这些步骤都是由独立的组合逻辑电路来完成的。

* <div align=center><img src="picture/流水线执行示意图.jpg"
        alt="No Picture"
        style="zoom:50%"/>
        <center><p>流水线执行示意图</p></center>
    </div>

    通过流水线设计，这样一来，不就需要像单指令周期处理器那样将时钟周期设置成整条指令执行的时间，而是拆分成完成这样的一个一个小步骤需要的时间。同时，每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。这里面每一个独立的步骤，称之为流水线阶段或者流水线级（Pipeline Stage）。

* 如果把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，那这就是一个三级的流水线。如果进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，那么它就会变成一个五级的流水线。五级的流水线，就表示CPU在同一个时钟周期里面，同时运行五条指令的不同阶段。这个时候，虽然执行一条指令的时钟周期变成了5，但是可以提高CPU的主频。**对于CPU而言，不需要确保最复杂的那条指令在时钟周期里面执行完成，而只要保障一个最复杂的流水线级的操作，在一个时钟周期内完成就好了**

* 若某一个操作步骤的时间太长，则可以考虑把这个步骤，拆分成更多的步骤，尽可能的让所有步骤需要执行的时间差距减少。这样一来，可以解决上述提到的单指令周期处理器中性能瓶颈——最复杂的指令问题。。如今，ARM或者Intel的CPU，流水线级数都已经到了14级。

* 虽然我们不能通过流水线，来减少单条指令执行的“延时”这个性能指标，但是，通过同时在执行多条指令的不同阶段，我们提升了 CPU 的“吞吐率”。在外部看来，我们的 CPU 好像是“一心多用”，在同一时间，同时执行 5 条不同指令的不同阶段。现代处理器在流水线中重叠这些阶段，就像装配线一样。在 CPU 内部，其实它就像生产线一样，不同分工的组件不断处理上游传递下来的内容，而不需要等待单件商品生产完成之后，再启动下一件商品的生产过程[<sup>[1]</sup>](#refer-anchor-1)。

* 由于时钟速度受到（除其他外）流水线中最长、最慢阶段的长度的限制，因此可以细分构成每个阶段的逻辑门，尤其是较长的逻辑门，将流水线转换为更深的超级流水线具有更多的较短阶段。下图可以看到一个超级流水线[<sup>[1]</sup>](#refer-anchor-1)
    <div align=center><img src="picture/超级流水线处理器的指令流.png"
        alt="No Picture"
        style="zoom:50%"/>
        <center><p>超级流水线处理器的指令流</p></center>
    </div>

#### 超长流水线的性能瓶颈

* 通过一个问题来看待超长流水线的性能瓶颈
    + *既然流水线可以增加吞吐率，为什么不把流水线级数做得更深，不做成20级，乃至40级呢？*

    + **原因是增加流水线深度有性能成本**，用来同步时钟周期的单位，不再是指令级别，而是细化到流水线阶段级别。每一级流水线对应的输出，都要放到流水线寄存器（Pipeline Register）里面，然后在下一个时钟周期，交给下一个流水线级去处理。

    + 所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有20皮秒（$\mathrm{ps, 10^{−12} s}$）。

    + <div align=center><img src="picture/超级流水线处理器的指令流.png"
        alt="No Picture"
        style="zoom:50%"/>
        <center><p>超级流水线处理器的指令流</p></center>
    </div>

#### 引用

<div id="refer-anchor-1"></div>

- [1] [Modern Microprocessors](https://www.lighterra.com/papers/modernmicroprocessors/)